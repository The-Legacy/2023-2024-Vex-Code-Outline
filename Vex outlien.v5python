{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nf_left = Motor(Ports.PORT4, GearSetting.RATIO_6_1, False)\nb_left = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\nb_right = Motor(Ports.PORT6, GearSetting.RATIO_6_1, False)\nf_right = Motor(Ports.PORT7, GearSetting.RATIO_18_1, False)\nintakes_motor_a = Motor(Ports.PORT11, GearSetting.RATIO_18_1, False)\nintakes_motor_b = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\nintakes = MotorGroup(intakes_motor_a, intakes_motor_b)\nsling = Motor(Ports.PORT3, GearSetting.RATIO_36_1, False)\nclimbing_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nclimbing_motor_b = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)\nclimbing = MotorGroup(climbing_motor_a, climbing_motor_b)\nflapjack_1 = DigitalOut(brain.three_wire_port.a)\nflapjack_2 = DigitalOut(brain.three_wire_port.b)\ninertial_one = Inertial(Ports.PORT8)\ncontroller_1 = Controller(PRIMARY)\nsling_limit = Limit(brain.three_wire_port.c)\ninertial_two = Inertial(Ports.PORT2)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n# Library imports\nfrom vex import *\nimport urandom\n\n# Begin project code\n\n#Wait for sensor initializaiton\nwait(30, MSEC)\n\n#vex imoprts\nimport math\n\n# Begin project Code\n\ndoug = 0\n\n# functions\n\n#Drive train motor braking functions\ndef Reset():\n    f_left.set_position(0, DEGREES)\n    f_right.set_position(0, DEGREES)\n    b_left.set_position(0, DEGREES)\n    b_right.set_position(0, DEGREES)\n\ndef Stop():\n    f_left.stop()\n    f_right.stop()\n    b_left.stop()\n    b_right.stop()\n\ndef braking_mode(m):\n    f_left.set_stopping(m)\n    f_right.set_stopping(m)\n    b_left.set_stopping(m)\n    b_right.set_stopping(m)\n\n# Forward functions\ndef forward(d, s):\n\n    Reset()\n\n    f_left.set_velocity(s, PERCENT)\n    f_right.set_velocity(s, PERCENT)\n    b_left.set_velocity(s, PERCENT)\n    b_right.set_velocity(s, PERCENT)\n\n    f_left.spin_for(FORWARD, d, DEGREES, wait=False)\n    f_right.spin_for(FORWARD, d, DEGREES, wait=False)\n    b_left.spin_for(FORWARD, d, DEGREES, wait=False)\n    b_right.spin_for(FORWARD, d, DEGREES, wait=True)\n\n    Stop()\n\ndef forwardtime(d, s, t):\n\n    Reset()\n\n    f_left.set_velocity(s, PERCENT)\n    f_right.set_velocity(s, PERCENT)\n    b_left.set_velocity(s, PERCENT)\n    b_right.set_velocity(s, PERCENT)\n\n    f_left.set_timeout(s, SECONDS)\n    f_right.set_timeout(s, SECONDS)\n    b_left.set_timeout(s, SECONDS)\n    b_right.set_timeout(s, SECONDS)\n\n    f_left.spin_for(FORWARD, d, DEGREES, wait=False)\n    f_right.spin_for(FORWARD, d, DEGREES, wait=False)\n    b_left.spin_for(FORWARD, d, DEGREES, wait=False)\n    b_right.spin_for(FORWARD, d, DEGREES, wait=True)\n\n    Stop()\n\ndef leftforward(s, d, t):\n    f_left.set_velocity(s, PERCENT)\n    b_left.set_velocity(s, PERCENT)\n\n    f_left.set_timeout(t, SECONDS)\n    b_left.set_timeout(t, SECONDS)\n\n    f_left.spin_for(FORWARD, d, DEGREES, wait=False)\n    b_left.spin_for(FORWARD, d, DEGREES, wait=False)\n\ndef rightforward(s, d, t):\n    f_right.set_velocity(s, PERCENT)\n    b_right.set_velocity(s, PERCENT)\n\n    f_right.set_timeout(t, SECONDS)\n    b_right.set_timeout(t, SECONDS)\n\n    f_right.spin_for(FORWARD, d, DEGREES, wait=False)\n    b_right.spin_for(FORWARD, d, DEGREES, wait=False)\n\n# Reverse functions\ndef reverse(d, s):\n\n    Reset()\n\n    f_left.set_velocity(s, PERCENT)\n    f_right.set_velocity(s, PERCENT)\n    b_left.set_velocity(s, PERCENT)\n    b_right.set_velocity(s, PERCENT)\n\n    f_left.spin_for(REVERSE, d, DEGREES, wait=False)\n    f_right.spin_for(REVERSE, d, DEGREES, wait=False)\n    b_left.spin_for(REVERSE, d, DEGREES, wait=False)\n    b_right.spin_for(REVERSE, d, DEGREES, wait=True)\n\n    Stop()\n\ndef reversetime(d, s, t):\n\n    Reset()\n\n    f_left.set_velocity(s, PERCENT)\n    f_right.set_velocity(s, PERCENT)\n    b_left.set_velocity(s, PERCENT)\n    b_right.set_velocity(s, PERCENT)\n\n    f_left.set_timeout(s, SECONDS)\n    f_right.set_timeout(s, SECONDS)\n    b_left.set_timeout(s, SECONDS)\n    b_right.set_timeout(s, SECONDS)\n\n    f_left.spin_for(REVERSE, d, DEGREES, wait=False)\n    f_right.spin_for(REVERSE, d, DEGREES, wait=False)\n    b_left.spin_for(REVERSE, d, DEGREES, wait=False)\n    b_right.spin_for(REVERSE, d, DEGREES, wait=True)\n\n    Stop()\n\ndef leftreverse(s, d, t):\n    f_left.set_velocity(s, PERCENT)\n    b_left.set_velocity(s, PERCENT)\n\n    f_left.set_timeout(t, SECONDS)\n    b_left.set_timeout(t, SECONDS)\n\n    f_left.spin_for(REVERSE, d, DEGREES, wait=False)\n    b_left.spin_for(REVERSE, d, DEGREES, wait=False)\n\ndef rightreverse(s, d, t):\n    f_right.set_velocity(s, PERCENT)\n    b_right.set_velocity(s, PERCENT)\n\n    f_right.set_timeout(t, SECONDS)\n    b_right.set_timeout(t, SECONDS)\n\n    f_right.spin_for(REVERSE, d, DEGREES, wait=False)\n    b_right.spin_for(REVERSE, d, DEGREES, wait=False)\n\ndef ifwd(d, s, h):\n    \n    Reset()\n\n    while (((f_left + b_left) / 2) + ((f_right + b_right) / 2)) < d:\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        pwr = abs(h - inertial_one.rotation(DEGREES))\n        if pwr > 100:\n            pwr = 100\n        \n        if inertial_one.rotation(DEGREES) > (.4 +h):\n            f_left.set_velocity(s, PERCENT)\n            b_left.set_velocity(s, PERCENT)\n            b_right.set_velocity(s + pwr, PERCENT)\n            f_right.set_velocity(s + pwr, PERCENT)\n\n        elif inertial_one.rotation(DEGREES) > (.4 + h):\n            f_left.set_velocity(s + pwr, PERCENT)\n            b_left.set_velocity(s + pwr, PERCENT)\n            b_right.set_velocity(s, PERCENT)\n            f_right.set_velocity(s, PERCENT)\n\n        else:\n            f_left.set_velocity(s, PERCENT)\n            b_left.set_velocity(s, PERCENT)\n            b_right.set_velocity(s, PERCENT)\n            f_right.set_velocity(s, PERCENT)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n\n    Stop()\n\ndef irev(d, s, h):\n    \n    Reset()\n\n    while (((f_left + b_left) / 2) + ((f_right + b_right) / 2)) > -d:\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        pwr = abs(h - inertial_one.rotation(DEGREES))\n        if pwr > 100:\n            pwr = 100\n        \n        if inertial_one.rotation(DEGREES) > (.4 +h):\n            f_left.set_velocity(-s - pwr, PERCENT)\n            b_left.set_velocity(-s - pwr, PERCENT)\n            b_right.set_velocity(-s, PERCENT)\n            f_right.set_velocity(-s, PERCENT)\n\n        elif inertial_one.rotation(DEGREES) > (.4 + h):\n            f_left.set_velocity(-s, PERCENT)\n            b_left.set_velocity(-s, PERCENT)\n            b_right.set_velocity(-s - pwr, PERCENT)\n            f_right.set_velocity(-s - pwr, PERCENT)\n\n        else:\n            f_left.set_velocity(-s, PERCENT)\n            b_left.set_velocity(-s, PERCENT)\n            b_right.set_velocity(-s, PERCENT)\n            f_right.set_velocity(-s, PERCENT)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n\n    Stop()\n\n#intake and shooting functions\n\ndef Intakes(s,d):\n    intakes.set_velocity(s, PERCENT)\n    intakes.spin(d)\n\ndef Intakesstop():\n    intakes.set_velocity(0, PERCENT)\n    intakes.stop()\n\ndef shoot():\n    sling.spin_for(FORWARD, 100, DEGREES, wait=True)\n\ndef shootcontinue():\n    sling.set_velocity(100, PERCENT)\n    sling.spin(forward)\n\n# Turning functions\ndef irightslow(h, s):\n    Reset()\n\n    while inertial_one.rotation(DEGREES) < h-.3:\n        pwr = (abs(h - inertial_one.rotation(DEGREES) * s) + 3)\n        if pwr > 40:\n            pwr = 40\n        \n        f_left.set_velocity(pwr, PERCENT)\n        f_right.set_velocity(pwr, PERCENT)\n        b_left.set_velocity(-pwr, PERCENT)\n        b_right.set_velocity(-pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n        else: \n            sling.stop()\n\n    Stop()\n    wait(.05, SECONDS)\n\n    while inertial_one.rotation(DEGREES) > h-.3:\n        pwr = (abs(h - inertial_one.rotation(DEGREES) * s) + 3)\n        if pwr > 40:\n            pwr = 40\n        \n        f_left.set_velocity(-pwr, PERCENT)\n        f_right.set_velocity(-pwr, PERCENT)\n        b_left.set_velocity(pwr, PERCENT)\n        b_right.set_velocity(pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n        else: \n            sling.stop()\n\n    Stop()\n        \ndef iright(h, s):\n    Reset()\n\n    while inertial_one.rotation(DEGREES) < h-.3:\n        pwr = (abs(h - inertial_one.rotation(DEGREES) * s) + 10)\n        if pwr > 40:\n            pwr = 40\n        \n        f_left.set_velocity(pwr, PERCENT)\n        f_right.set_velocity(pwr, PERCENT)\n        b_left.set_velocity(-pwr, PERCENT)\n        b_right.set_velocity(-pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n        else: \n            sling.stop()\n\n    Stop()\n    wait(.05, SECONDS)\n\n    while inertial_one.rotation(DEGREES) > h-.3:\n        pwr = (abs(h - inertial_one.rotation(DEGREES) * s) + 10)\n        if pwr > 40:\n            pwr = 40\n        \n        f_left.set_velocity(-pwr, PERCENT)\n        f_right.set_velocity(-pwr, PERCENT)\n        b_left.set_velocity(pwr, PERCENT)\n        b_right.set_velocity(pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n        else: \n            sling.stop()\n\n    Stop()\n\ndef ileftslow(h, s):\n    Reset()\n\n    while inertial_one.rotation(DEGREES) < h-.3:\n        pwr = (abs(h - inertial_one.rotation(DEGREES) * s) + 3)\n        if pwr > 40:\n            pwr = 40\n        \n        f_left.set_velocity(-pwr, PERCENT)\n        f_right.set_velocity(pwr, PERCENT)\n        b_left.set_velocity(pwr, PERCENT)\n        b_right.set_velocity(pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n        else: \n            sling.stop()\n\n    Stop()\n    wait(.05, SECONDS)\n\n    while inertial_one.rotation(DEGREES) > h-.3:\n        pwr = (abs(h - inertial_one.rotation(DEGREES) * s) + 3)\n        if pwr > 40:\n            pwr = 40\n        \n        f_left.set_velocity(pwr, PERCENT)\n        f_right.set_velocity(pwr, PERCENT)\n        b_left.set_velocity(-pwr, PERCENT)\n        b_right.set_velocity(-pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n        else: \n            sling.stop()\n\n    Stop()\n        \ndef ileft(h, s):\n    Reset()\n\n    while inertial_one.rotation(DEGREES) < h-.3:\n        pwr = (abs(h - inertial_one.rotation(DEGREES) * s) + 10)\n        if pwr > 40:\n            pwr = 40\n        \n        f_left.set_velocity(-pwr, PERCENT)\n        f_right.set_velocity(-pwr, PERCENT)\n        b_left.set_velocity(pwr, PERCENT)\n        b_right.set_velocity(pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n        else: \n            sling.stop()\n\n    Stop()\n    wait(.05, SECONDS)\n\n    while inertial_one.rotation(DEGREES) > h-.3:\n        pwr = (abs(h - inertial_one.rotation(DEGREES) * s) + 10)\n        if pwr > 40:\n            pwr = 40\n        \n        f_left.set_velocity(pwr, PERCENT)\n        f_right.set_velocity(pwr, PERCENT)\n        b_left.set_velocity(-pwr, PERCENT)\n        b_right.set_velocity(-pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n        if sling_limit.pressing() == False:\n            sling.set_velocity(75, PERCENT)\n        else: \n            sling.stop()\n\n    Stop()\n\ndef wideright(h, s, p):\n\n    Reset()\n\n    while inertial_one.rotation(DEGREES) < h - .5:\n        pwr = (abs(h - inertial_one.rotation(DEGREES)) * s) + 3\n\n        f_left.set_velocity(s*pwr, PERCENT)\n        b_left.set_velocity(s*pwr, PERCENT)\n        f_right.set_velocity(s*pwr*p, PERCENT)\n        b_right.set_velocity(s*pwr*p, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\ndef wideleft(h, s, p):\n\n    Reset()\n\n    while inertial_one.rotation(DEGREES) < h - .5:\n        pwr = (abs(h - inertial_one.rotation(DEGREES)) * s) + 3\n\n        f_left.set_velocity(s*pwr*p, PERCENT)\n        b_left.set_velocity(s*pwr*p, PERCENT)\n        f_right.set_velocity(s*pwr, PERCENT)\n        b_right.set_velocity(s*pwr, PERCENT)\n\n        f_left.spin(FORWARD)\n        f_right.spin(FORWARD)\n        b_left.spin(FORWARD)\n        b_right.spin(FORWARD)\n\n#pneumatic functions\ndef flapjacks(b):\n    flapjack_1.set(b)\n    flapjack_2.set(b)\n\ndef driverflapjacks():\n    global doug\n    doug = doug + 1\n    return doug\n\n#initializing function\ndef when_started1():\n    inertial_one.calibrate()\n    inertial_two.calibrate()\n    flapjack_1.set(False)\n    flapjack_2.set(False)\n    sling.set_stopping(BRAKE)\n    climbing.set_stopping(BRAKE)\n    intakes.set_stopping(BRAKE)\n\n#autonomous actions\ndef onauton_autonomous_0():\n    braking_mode(BRAKE)\n    braking_mode(COAST)\n\n#driver control settings\ndef ondriver_drivercontrol_0():\n    global doug\n\n    controller_1.buttonRight.pressed(driverflapjacks())\n\n    if (sling_limit.pressing() == False):\n        sling.set_velocity(75, PERCENT)\n        sling.spin(FORWARD)\n\n    #drive train\n    if(controller_1.axis3.position() > 5 or controller_1.axis2.position > 5 or controller_1.axis3.position() < -5 or controller_1.axis2.position() < -5):\n        f_left.set_velocity(controller_1.axis3.position(), PERCENT)\n        b_left.set_velocity(controller_1.axis3.position(), PERCENT)\n        f_right.set_velocity(controller_1.axis2.position(), PERCENT)\n        b_right.set_velocity(controller_1.axis2.position(), PERCENT)\n    \n    f_left.spin(FORWARD)\n    f_right.spin(FORWARD)\n    b_left.spin(FORWARD)\n    b_right.spin(FORWARD)\n\n    #intakes\n\n    if (controller_1.buttonL2.pressing()):\n        intakes.set_velocity(75, PERCENT)\n        intakes.spin(FORWARD)\n    elif (controller_1.buttonL1.pressing()):\n        intakes.set_velocity(-75, PERCENT)\n        intakes.spin(FORWARD)\n    else:\n        intakes.stop()\n\n    #slingshot\n    controller_1.buttonR2.pressed(shoot())\n\n    #EMERGENCY SLING REVERSE\n    if(controller_1.buttonA.pressing()):\n        sling.set_velocity(25, PERCENT)\n        sling.spin(REVERSE)\n\n    #climbing\n    if(controller_1.buttonUp.pressing()):\n        climbing.set_velocity(50, PERCENT)\n        climbing.spin(FORWARD)\n    elif(controller_1.buttonDown.pressing()):\n        climbing.set_velocity(50, PERCENT)\n        climbing.spin(REVERSE)\n    else:\n        climbing.stop()\n\n    #pnuematics\n    if(doug % 2 == 1):\n        flapjack_1.set(True)\n        flapjack_2.set(True)\n    else:\n        flapjack_1.set(False)\n        flapjack_2.set(False)\n\n#competition template for autonomous actions\ndef vexcode_auton_function():\n    auton_task_0 = Thread(onauton_autonomous_0)\n\n    while (competition.is_enabled() and competition.is_autonomous):\n        wait(10, MSEC)\n        auton_task_0.stop()\n\n#competition template for driver control actions\ndef vexcode_driver_function():\n    driver_control_task_0 = Thread(ondriver_drivercontrol_0)\n\n    while(competition.is_driver_control() and competition.is_enabled()):\n        wait(10, MSEC)\n        driver_control_task_0.stop()\n\n#competition for autonomous and driver\ncompetition = Competition(vexcode_driver_function, vexcode_auton_function)\n\n#initializing\nwhen_started1()","textLanguage":"python","rconfig":[{"port":[4],"name":"f_left","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[5],"name":"b_left","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[6],"name":"b_right","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[7],"name":"f_right","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[11,10],"name":"intakes","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[3],"name":"sling","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[1,12],"name":"climbing","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[1],"name":"flapjack_1","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[2],"name":"flapjack_2","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[8],"name":"inertial_one","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[3],"name":"sling_limit","customName":true,"deviceType":"LimitSwitch","deviceClass":"limit","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"inertial_two","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"}}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}